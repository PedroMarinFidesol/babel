# Sesion 2026-01-25 19:36 - Fase 2: CQRS con MediatR

## Resumen de la Sesion

Implementacion completa de la Fase 2 del roadmap: infraestructura CQRS con MediatR. Se creo el patron Result para manejo funcional de errores, interfaces ICommand/IQuery, behaviors de pipeline (Logging, Validation, ExceptionHandling), y repositorios con Unit of Work. Se anadio un proyecto de tests con 31 tests unitarios.

## Cambios Implementados

### 1. Patron Result y Error

**src/Babel.Application/Common/Error.cs**
```csharp
namespace Babel.Application.Common;

public sealed record Error(string Code, string Description)
{
    public static readonly Error None = new(string.Empty, string.Empty);
    public static readonly Error NullValue = new("Error.NullValue", "El valor proporcionado es nulo.");

    public static Error Validation(string code, string description) =>
        new($"Validation.{code}", description);
}
```

**src/Babel.Application/Common/Result.cs**
```csharp
public class Result
{
    public bool IsSuccess { get; }
    public bool IsFailure => !IsSuccess;
    public Error Error { get; }

    protected Result(bool isSuccess, Error error)
    {
        IsSuccess = isSuccess;
        Error = error;
    }

    public static Result Success() => new(true, Error.None);
    public static Result Failure(Error error) => new(false, error);
    public static Result<T> Success<T>(T value) => new(value, true, Error.None);
    public static Result<T> Failure<T>(Error error) => new(default, false, error);
}

public class Result<T> : Result
{
    public T? Value { get; }
    // ... implementacion completa
}
```

**src/Babel.Application/Common/DomainErrors.cs**
- Errores predefinidos para Project, Document y DocumentChunk
- Errores de validacion, no encontrado, operaciones fallidas

### 2. Interfaces CQRS

**src/Babel.Application/Common/ICommand.cs**
```csharp
public interface ICommand : IRequest<Result> { }
public interface ICommand<TResponse> : IRequest<Result<TResponse>> { }
public interface ICommandHandler<in TCommand> : IRequestHandler<TCommand, Result>
    where TCommand : ICommand { }
public interface ICommandHandler<in TCommand, TResponse> : IRequestHandler<TCommand, Result<TResponse>>
    where TCommand : ICommand<TResponse> { }
```

**src/Babel.Application/Common/IQuery.cs**
```csharp
public interface IQuery<TResponse> : IRequest<Result<TResponse>> { }
public interface IQueryHandler<in TQuery, TResponse> : IRequestHandler<TQuery, Result<TResponse>>
    where TQuery : IQuery<TResponse> { }
```

### 3. Behaviors de Pipeline

**LoggingBehavior** - Log de inicio/fin con medicion de tiempo
**ValidationBehavior** - Ejecuta validadores FluentValidation antes del handler
**ExceptionHandlingBehavior** - Captura excepciones y las convierte a Result.Failure

### 4. Repositorios

**Interfaces en Application:**
- `IRepository<T>` - CRUD generico con async
- `IUnitOfWork` - Transacciones y SaveChanges
- `IProjectRepository` - Metodos especificos de Project
- `IDocumentRepository` - Metodos especificos de Document

**Implementaciones en Infrastructure:**
- `RepositoryBase<T>` - Implementacion EF Core generica
- `ProjectRepository` - Incluye GetWithDocumentsAsync, ExistsWithNameAsync
- `DocumentRepository` - Incluye GetByProjectAsync, GetPendingVectorizationAsync
- `UnitOfWork` - Manejo de transacciones con BeginTransactionAsync/CommitAsync/RollbackAsync

### 5. DependencyInjection

**src/Babel.Application/DependencyInjection.cs**
```csharp
public static IServiceCollection AddApplication(this IServiceCollection services)
{
    var assembly = Assembly.GetExecutingAssembly();

    services.AddMediatR(cfg =>
    {
        cfg.RegisterServicesFromAssembly(assembly);
        cfg.AddBehavior(typeof(IPipelineBehavior<,>), typeof(LoggingBehavior<,>));
        cfg.AddBehavior(typeof(IPipelineBehavior<,>), typeof(ValidationBehavior<,>));
        cfg.AddBehavior(typeof(IPipelineBehavior<,>), typeof(ExceptionHandlingBehavior<,>));
    });

    services.AddValidatorsFromAssembly(assembly);

    return services;
}
```

**Actualizacion en Infrastructure/DependencyInjection.cs:**
```csharp
services.AddScoped<IProjectRepository, ProjectRepository>();
services.AddScoped<IDocumentRepository, DocumentRepository>();
services.AddScoped<IUnitOfWork, UnitOfWork>();
```

### 6. Proyecto de Tests

**tests/Babel.Application.Tests/** - 31 tests unitarios:
- `Common/ErrorTests.cs` - 6 tests para Error
- `Common/ResultTests.cs` - 11 tests para Result y Result<T>
- `Behaviors/LoggingBehaviorTests.cs` - 4 tests
- `Behaviors/ValidationBehaviorTests.cs` - 5 tests
- `Behaviors/ExceptionHandlingBehaviorTests.cs` - 5 tests

## Problemas Encontrados y Soluciones

### 1. MediatR 14 - Cambio en RequestHandlerDelegate

**Problema:** `CS1593: Delegate 'RequestHandlerDelegate<Result<string>>' does not take 0 arguments`

**Causa:** MediatR 14 para .NET 10 cambio la firma de `RequestHandlerDelegate<TResponse>` para aceptar un `CancellationToken`.

**Solucion:** Cambiar la sintaxis de lambda de `() => Task.FromResult(...)` a `_ => Task.FromResult(...)`:
```csharp
// Antes (MediatR 12)
RequestHandlerDelegate<Result<string>> next = () => Task.FromResult(expectedResult);

// Ahora (MediatR 14)
RequestHandlerDelegate<Result<string>> next = _ => Task.FromResult(expectedResult);
```

### 2. NSubstitute - Records Privados

**Problema:** `Castle.DynamicProxy.Generators.GeneratorException: Type TestRequest is not accessible`

**Causa:** NSubstitute no puede crear proxies de tipos privados (records anidados en clases de test).

**Solucion:** Hacer los records de test publicos a nivel de namespace:
```csharp
// Antes
public class ValidationBehaviorTests
{
    private record TestRequest(string Name) : IRequest<Result<string>>;
}

// Despues
public record ValidationTestRequest(string Name) : IRequest<Result<string>>;

public class ValidationBehaviorTests
{
    // Usar ValidationTestRequest
}
```

### 3. Warning CS0168 - Variable no usada

**Problema:** Warning por variable `ex` no usada en catch de ValidationException

**Solucion:** Eliminar el nombre de variable:
```csharp
// Antes
catch (FluentValidation.ValidationException ex)

// Despues
catch (FluentValidation.ValidationException)
```

## Desafios Tecnicos

### Compatibilidad MediatR 14 con .NET 10

MediatR 14.0.0 introduce cambios en las firmas de delegados para soportar mejor la propagacion de CancellationToken. Esto afecta a:
- `RequestHandlerDelegate<TResponse>` ahora recibe CancellationToken
- Los behaviors deben pasar el token a `next()`

### Reflection en ExceptionHandlingBehavior

Para crear Result.Failure<T> dinamicamente cuando T es desconocido en tiempo de compilacion:
```csharp
var resultType = typeof(TResponse);
if (resultType.IsGenericType && resultType.GetGenericTypeDefinition() == typeof(Result<>))
{
    var valueType = resultType.GetGenericArguments()[0];
    var failureMethod = typeof(Result)
        .GetMethod(nameof(Result.Failure), 1, [typeof(Error)])!
        .MakeGenericMethod(valueType);
    return (TResponse)failureMethod.Invoke(null, [error])!;
}
```

## Configuracion Final

### Paquetes Instalados

**Babel.Application.csproj:**
```xml
<PackageReference Include="FluentValidation" Version="11.11.0" />
<PackageReference Include="FluentValidation.DependencyInjectionExtensions" Version="11.11.0" />
```

**Babel.Application.Tests.csproj:**
```xml
<PackageReference Include="FluentAssertions" Version="8.0.1" />
<PackageReference Include="FluentValidation" Version="11.11.0" />
<PackageReference Include="MediatR" Version="14.0.0" />
<PackageReference Include="NSubstitute" Version="5.3.0" />
<PackageReference Include="xunit" Version="2.9.3" />
```

## Proximos Pasos

1. **Fase 3: Gestion de Proyectos**
   - Crear migracion EF para los nuevos campos de entidades
   - Implementar CreateProjectCommand, GetProjectsQuery
   - Conectar WebUI con servicios reales

2. **Fase 4: Gestion de Documentos**
   - UploadDocumentsCommand
   - FileStorageService
   - Servicio de chunking

## Comandos Utiles

```bash
# Compilar solucion
dotnet build

# Ejecutar tests
dotnet test

# Ejecutar tests con detalle
dotnet test --logger "console;verbosity=detailed"

# Merge a main desde worktree
git -C "C:/Users/pmarin/babel" fetch origin
git -C "C:/Users/pmarin/babel" merge origin/bold-goodall --no-edit
git -C "C:/Users/pmarin/babel" push origin main
```

## Lecciones Aprendidas

1. **MediatR 14 Breaking Changes:** Siempre revisar los cambios de breaking en versiones mayores de MediatR, especialmente las firmas de delegados.

2. **NSubstitute y Tipos Privados:** Los tipos usados con NSubstitute deben ser publicos para que Castle.DynamicProxy pueda crear proxies.

3. **Patron Result:** Es fundamental tener metodos estaticos bien definidos (`Success`, `Failure`, `Success<T>`, `Failure<T>`) para facilitar su uso en handlers.

4. **Git Worktrees:** No se puede hacer checkout de una rama que ya esta en uso en otro worktree. Usar `git -C` para operar en el repositorio principal.

## Estado Final del Proyecto

### Completado
- [x] Patron Result y Error implementado
- [x] Interfaces ICommand/IQuery con handlers
- [x] LoggingBehavior con medicion de tiempo
- [x] ValidationBehavior con FluentValidation
- [x] ExceptionHandlingBehavior con conversion a Result.Failure
- [x] IRepository generico
- [x] IUnitOfWork con transacciones
- [x] IProjectRepository y IDocumentRepository
- [x] Implementaciones EF Core de repositorios
- [x] DependencyInjection.AddApplication()
- [x] 31 tests unitarios pasando
- [x] Merge a main completado

### Tests
- Total: 58 tests (27 Domain + 31 Application)
- Todos pasando

### Archivos Creados/Modificados
- 29 archivos, 2633 lineas anadidas
