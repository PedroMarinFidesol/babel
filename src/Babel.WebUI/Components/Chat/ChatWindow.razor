@using Babel.WebUI.Services
@using System.Text
@inject IJSRuntime JS
@inject IChatApiService ChatApi
@inject ISnackbar Snackbar
@inject ILogger<ChatWindow> Logger
@implements IDisposable

<MudPaper Elevation="2" Class="d-flex flex-column" Style="height: 500px;">
    <MudToolBar Dense="true" Class="px-4">
        <MudIcon Icon="@Icons.Material.Filled.Chat" Class="mr-2" />
        <MudText Typo="Typo.subtitle1">Chat RAG</MudText>
        <MudSpacer />
        @* Toggle para streaming *@
        <MudTooltip Text="@(_useStreaming ? "Streaming activado" : "Streaming desactivado")">
            <MudToggleIconButton @bind-Toggled="_useStreaming"
                                 Icon="@Icons.Material.Filled.Stream"
                                 ToggledIcon="@Icons.Material.Filled.Stream"
                                 Size="Size.Small"
                                 Color="@(_useStreaming ? Color.Primary : Color.Default)" />
        </MudTooltip>
        <MudTooltip Text="Limpiar conversacion">
            <MudIconButton Icon="@Icons.Material.Filled.DeleteSweep"
                           Size="Size.Small"
                           OnClick="@ClearChat"
                           Disabled="@(_messages.Count == 0 || _isProcessing)" />
        </MudTooltip>
    </MudToolBar>

    <MudDivider />

    <div @ref="_chatContainer" class="flex-grow-1 overflow-auto pa-4"
         style="background-color: var(--mud-palette-background-grey);">
        @if (_messages.Count == 0)
        {
            <div class="d-flex flex-column align-center justify-center" style="height: 100%;">
                <MudIcon Icon="@Icons.Material.Filled.QuestionAnswer"
                         Size="Size.Large" Color="Color.Secondary" Class="mb-2" />
                <MudText Typo="Typo.body1" Color="Color.Secondary">No hay mensajes</MudText>
                <MudText Typo="Typo.body2" Color="Color.Secondary">
                    Escribe una pregunta sobre los documentos del proyecto
                </MudText>
            </div>
        }
        else
        {
            @foreach (var message in _messages)
            {
                <ChatMessage Message="@message" OnReferenceClick="@HandleReferenceClick" />
            }

            @if (_isProcessing && !_useStreaming)
            {
                <div class="d-flex align-center pa-2 mb-2">
                    <MudProgressCircular Size="Size.Small" Indeterminate="true" Class="mr-2" />
                    <MudText Typo="Typo.body2" Color="Color.Secondary">
                        Analizando documentos...
                    </MudText>
                </div>
            }
        }
    </div>

    <MudDivider />

    <div class="pa-3">
        <MudTextField @bind-Value="_currentMessage"
                      Placeholder="Escribe tu pregunta..."
                      Variant="Variant.Outlined"
                      Adornment="Adornment.End"
                      AdornmentIcon="@Icons.Material.Filled.Send"
                      AdornmentColor="Color.Primary"
                      OnAdornmentClick="@SendMessageAsync"
                      OnKeyUp="@HandleKeyUp"
                      Disabled="@_isProcessing"
                      Immediate="true"
                      FullWidth="true"
                      Margin="Margin.None" />
    </div>
</MudPaper>

@code {
    [Parameter]
    public Guid ProjectId { get; set; }

    [Parameter]
    public EventCallback<Guid> OnDocumentReferenceClick { get; set; }

    private List<ChatMessageDto> _messages = [];
    private string _currentMessage = "";
    private bool _isProcessing;
    private bool _useStreaming = true;
    private ElementReference _chatContainer;
    private CancellationTokenSource? _cts;
    private ILogger<ChatWindow>? _logger;

    protected override void OnInitialized()
    {
        _logger = Logger;
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (_messages.Count > 0)
        {
            await ScrollToBottomAsync();
        }
    }

    private async Task HandleKeyUp(KeyboardEventArgs e)
    {
        if (e.Key == "Enter" && !e.ShiftKey && !string.IsNullOrWhiteSpace(_currentMessage))
        {
            await SendMessageAsync();
        }
    }

    private async Task SendMessageAsync()
    {
        if (string.IsNullOrWhiteSpace(_currentMessage) || _isProcessing) return;

        var userMessage = _currentMessage.Trim();
        _currentMessage = "";
        _isProcessing = true;
        _cts = new CancellationTokenSource();

        // Agregar mensaje del usuario inmediatamente
        _messages.Add(new ChatMessageDto
        {
            Content = userMessage,
            IsUser = true,
            Timestamp = DateTime.UtcNow
        });

        StateHasChanged();
        await ScrollToBottomAsync();

        try
        {
            if (_useStreaming)
            {
                await SendWithStreamingAsync(userMessage);
            }
            else
            {
                await SendWithoutStreamingAsync(userMessage);
            }
        }
        catch (OperationCanceledException)
        {
            // Usuario canceló - no mostrar error
        }
        catch (Exception ex)
        {
            _messages.Add(new ChatMessageDto
            {
                Content = $"Error: {ex.Message}",
                IsUser = false,
                Timestamp = DateTime.UtcNow
            });
            Snackbar.Add("Error al procesar la pregunta", Severity.Error);
        }
        finally
        {
            _isProcessing = false;
            _cts?.Dispose();
            _cts = null;
            StateHasChanged();
            await ScrollToBottomAsync();
        }
    }

    private async Task SendWithoutStreamingAsync(string userMessage)
    {
        var response = await ChatApi.SendMessageAsync(ProjectId, userMessage, _cts!.Token);

        if (response is null)
        {
            _messages.Add(new ChatMessageDto
            {
                Content = "Lo siento, hubo un error al procesar tu pregunta. Por favor, intenta de nuevo.",
                IsUser = false,
                Timestamp = DateTime.UtcNow
            });
            return;
        }

        _messages.Add(new ChatMessageDto
        {
            Content = response.Response,
            IsUser = false,
            Timestamp = DateTime.UtcNow,
            References = response.References
        });
    }

    private async Task SendWithStreamingAsync(string userMessage)
    {
        var contentBuilder = new StringBuilder();
        var assistantMessage = new ChatMessageDto
        {
            Content = "",
            IsUser = false,
            Timestamp = DateTime.UtcNow,
            References = []
        };

        // Agregar mensaje vacío que iremos llenando
        _messages.Add(assistantMessage);
        StateHasChanged();

        await foreach (var evt in ChatApi.SendMessageStreamAsync(
            ProjectId, userMessage, _cts!.Token))
        {
            switch (evt.EventType)
            {
                case "token":
                    contentBuilder.Append(evt.Data);
                    assistantMessage.Content = contentBuilder.ToString();
                    await InvokeAsync(StateHasChanged);
                    await ScrollToBottomAsync();
                    break;

                case "references":
                    _logger.LogInformation("Evento references recibido. Count: {Count}", evt.References?.Count ?? 0);
                    if (evt.References != null && evt.References.Count > 0)
                    {
                        assistantMessage.References = evt.References;
                        await InvokeAsync(StateHasChanged);
                    }
                    break;

                case "error":
                    if (contentBuilder.Length == 0)
                    {
                        assistantMessage.Content = $"Error: {evt.Data}";
                    }
                    else
                    {
                        assistantMessage.Content = contentBuilder + $"\n\n[Error: {evt.Data}]";
                    }
                    Snackbar.Add(evt.Data, Severity.Error);
                    break;

                case "cancelled":
                    if (contentBuilder.Length > 0)
                    {
                        assistantMessage.Content = contentBuilder + "\n\n[Cancelado]";
                    }
                    break;

                case "done":
                    _logger.LogInformation("Streaming completado");
                    // Streaming completado
                    break;
            }
        }

        // Asegurar que el contenido final está actualizado
        if (contentBuilder.Length > 0)
        {
            assistantMessage.Content = contentBuilder.ToString();
        }
    }

    private void ClearChat()
    {
        _cts?.Cancel();
        _messages.Clear();
    }

    private async Task HandleReferenceClick(Guid documentId)
    {
        await OnDocumentReferenceClick.InvokeAsync(documentId);
    }

    private async Task ScrollToBottomAsync()
    {
        try
        {
            await JS.InvokeVoidAsync("scrollToBottom", _chatContainer);
        }
        catch
        {
            // Ignorar errores de JS interop durante prerendering
        }
    }

    public void Dispose()
    {
        _cts?.Cancel();
        _cts?.Dispose();
    }
}
